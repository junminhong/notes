# Day19 - 效能優化與平行處理

## 今日目標
- 了解影響 Ansible 效能的關鍵
- 掌握平行與策略：`forks`、`strategy`、`serial`、`throttle`、`async`

## 快速加速清單
- 降低開銷：非必要時 `gather_facts: false`，需要時用 `setup: gather_subset` 精準蒐集。
- 提高並行：調整 `forks`（預設 5），並視情況使用 `strategy: free`。
- 重用連線：啟用 SSH pipelining、ControlPersist，降低每次連線成本。
- 合併操作：能一次處理就不要切多任務（例如 `package: name: [a,b,c]`）。
- 避免子殼層：能用模組就別用 `shell/command` 迴圈。
- 適度分批：用 `serial` 滾動佈署、`throttle` 限制重操作的併發。
- 善用快取：Facts 快取（見 Day13），避免每次全量收集。

## ansible.cfg 的小建議
```ini
[defaults]
forks = 20
timeout = 30
gathering = smart

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=60s -o ControlPath=~/.ssh/ansible-ctl-%%r@%%h:%%p
```

> 提高 `forks` 要注意遠端機器跟網路的負載，建議慢慢增加並觀察。

## 舉個例蓻
```yaml
---
# perf-demo.yml
- name: Day19 performance & parallel demo
  hosts: all
  gather_facts: false
  strategy: free        # 各主機不互等，加快整體時間
  serial: 50%           # 滾動佈署，降低一次性風險
  any_errors_fatal: true
  max_fail_percentage: 20

  tasks:
    - name: Prepare working dir
      file:
        path: /tmp/perf-demo
        state: directory
        mode: '0755'

    - name: Create multiple files (合併操作減少 I/O)
      file:
        path: "/tmp/perf-demo/{{ item }}"
        state: touch
        mode: '0644'
      loop:
        - a.txt
        - b.txt
        - c.txt

    - name: Simulate heavy work in background (async)
      shell: sleep 10 && echo done > /tmp/perf-demo/async.txt
      async: 120      # 最多允許 120 秒
      poll: 0         # 不中斷等待，背景執行
      register: heavy_async

    - name: Throttled operation (限制單任務併發)
      lineinfile:
        path: /tmp/perf-demo/throttle.txt
        line: "{{ inventory_hostname }} updated"
        create: yes
      throttle: 2      # 同時最多 2 台主機執行

    - name: Run once for all (一次性前置)
      debug:
        msg: "Generating shared artifact..."
      run_once: true

    - name: Wait for background job to finish
      async_status:
        jid: "{{ heavy_async.ansible_job_id }}"
      register: heavy_status
      until: heavy_status.finished
      retries: 30
      delay: 2
```
來執行看看
```bash
# 實際執行時可提高 forks
ansible-playbook -i inventory.ini perf-demo.yml -f 20
```


## 平行與策略組合
- `strategy: free`：同一 Play 的主機不互等，誰先完成誰先跑下一步。
- `serial`：分批滾動佈署；搭配 `max_fail_percentage`、`any_errors_fatal` 控制失敗門檻。
- `throttle`：限制「單一任務」同時併發數，避免重操作壓垮資源。
- `async/poll`：長耗時任務改背景執行；`poll: 0` 先放背景，再用 `async_status` 追蹤完成。

## 其他提升手法
- 控制蒐集：Play 預設 `gather_facts: false`，需要時再 `setup` 並以 `gather_subset` 精準收集。
- `run_once` + `delegate_to`：昂貴操作只做一次（如下載 artifact），再分發到各主機。
- 合併 I/O：同類變更集中於少數任務，避免大量細碎 I/O。
- 避免不必要的變更：善用 `creates`/`removes`、合理的 `changed_when` 與 `--check --diff` 預檢。
- 任務靜態化：偏向 `import_tasks`（靜態）而非 `include_tasks`（動態）可減解析期開銷（依需求取捨）。

## 最佳實務
- 先量測再調整：以 `-vv` 觀察瓶頸（等待、連線、任務耗時）。
- 小步快跑：逐步提高 `forks`，同時監控目標端負載與網路。
- 安全落地：批次變更一律 `serial` 滾動，設定 `max_fail_percentage`、`any_errors_fatal`。
- 背景作業：長任務使用 `async/poll`，避免阻塞整體流程。
- 降低連線開銷：`pipelining`、ControlPersist 與合理 SSH 參數。
- 重用資料：啟用 Facts 快取並設定合理 TTL（見 Day13）。

## 常見問題與排錯
- 加了 `strategy: free` 卻沒變快？瓶頸可能在單一任務本身 (I/O)，或 `serial` 批次太小。
- `forks` 提太大導致失敗：遠端主機資源不足或網路擁塞，。
- `async` 任務沒結束：提高 `async` 上限並以 `async_status` 追蹤，或檢查遠端程式實際耗時。
- `throttle` 看似無效：僅限制該任務的同時併發，不影響其他任務或整體 forks。

## 作業練習時間
- 練習 1：將你的 Play 設為 `strategy: free`，實測 `-f 5/20/50` 差異。
- 練習 2：為影響線上服務的任務加上 `serial: 25%` 與 `max_fail_percentage`，觀察滾動行為。
- 練習 3：挑一個長任務改為 `async/poll`，並用 `async_status` 輪詢完成狀態。

## 明日預告
> 明天我們來做自己的模組
