# Day23 - CI/CD 整合

## 今日目標
- 了解 CI/CD 的核心概念與優勢
- 掌握 Jenkins 與 Ansible 的整合應用
- 學會設計 GitLab CI/CD Pipeline
- 建立完整的自動化部署流程

## 為什麼需要 CI/CD 整合？

在現代軟體開發中，CI/CD（持續整合/持續部署）已經成為必備的實務：

**持續整合 (Continuous Integration)**：
- 自動化代碼合併和測試
- 及早發現整合問題
- 確保代碼品質一致性

**持續部署 (Continuous Deployment)**：
- 自動化部署流程
- 減少人為錯誤
- 快速交付新功能

Ansible 在 CI/CD 流程中扮演關鍵角色：
- **基礎設施即代碼**：確保環境一致性
- **多環境管理**：統一的部署流程
- **冪等性**：安全的重複執行
- **豐富的模組**：支援各種部署需求

## Jenkins 與 Ansible 整合

### 1. Jenkins 環境準備

**安裝 Ansible 插件**：
```bash
# 在 Jenkins 中安裝 Ansible Plugin
# 管理 Jenkins → 管理插件 → 可用插件 → 搜尋 "Ansible"
```

**配置 Ansible 工具**：
```bash
# 全域工具配置 → Ansible installations
# Name: ansible
# Path to ansible executables directory: /usr/local/bin/
```

### 2. Jenkins Pipeline 與 Ansible

**Declarative Pipeline** (`Jenkinsfile`)：
```groovy
pipeline {
    agent any

    environment {
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_FORCE_COLOR = 'true'
    }

    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: '選擇部署環境'
        )
        string(
            name: 'VERSION',
            defaultValue: 'latest',
            description: '應用程式版本'
        )
    }

    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', url: 'https://github.com/your-org/ansible-playbooks.git'
            }
        }

        stage('Lint Check') {
            steps {
                sh '''
                    ansible-lint playbooks/
                    yamllint .
                '''
            }
        }

        stage('Syntax Check') {
            steps {
                ansiblePlaybook(
                    playbook: 'playbooks/site.yml',
                    inventory: "inventories/${params.ENVIRONMENT}/inventory.ini",
                    extras: '--syntax-check'
                )
            }
        }

        stage('Deploy') {
            steps {
                ansiblePlaybook(
                    playbook: 'playbooks/site.yml',
                    inventory: "inventories/${params.ENVIRONMENT}/inventory.ini",
                    extras: "--extra-vars 'app_version=${params.VERSION}'",
                    credentialsId: 'ansible-vault-password'
                )
            }
        }

        stage('Verify Deployment') {
            steps {
                ansiblePlaybook(
                    playbook: 'playbooks/verify.yml',
                    inventory: "inventories/${params.ENVIRONMENT}/inventory.ini"
                )
            }
        }

        stage('Notify') {
            steps {
                script {
                    if (currentBuild.result == 'SUCCESS') {
                        slackSend(
                            color: 'good',
                            message: "✅ 部署成功: ${env.JOB_NAME} - ${params.ENVIRONMENT} - ${params.VERSION}"
                        )
                    } else {
                        slackSend(
                            color: 'danger',
                            message: "❌ 部署失敗: ${env.JOB_NAME} - ${params.ENVIRONMENT}"
                        )
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        failure {
            emailext(
                subject: "部署失敗: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                body: "部署到 ${params.ENVIRONMENT} 環境失敗，請檢查 Jenkins 日誌。",
                to: "devops@company.com"
            )
        }
    }
}
```

### 3. Jenkins 作業配置

**自由式專案配置**：
```bash
# 建置觸發器
- GitHub hook trigger for GITScm polling
- Poll SCM: H/5 * * * *  # 每5分鐘檢查一次

# 建置環境
- Delete workspace before build starts
- Abort the build if it's stuck (Timeout: 30 minutes)

# 建置步驟
1. Execute shell:
   ansible-lint playbooks/

2. Invoke Ansible Playbook:
   Playbook path: playbooks/site.yml
   Inventory: inventories/$ENVIRONMENT/inventory.ini
   Vault Credentials: ansible-vault-password
   Extra Variables: app_version=$VERSION environment=$ENVIRONMENT
```

## GitLab CI/CD 整合

### 1. GitLab CI 配置

**`.gitlab-ci.yml` 完整範例**：
```yaml
stages:
  - validate
  - test
  - deploy-dev
  - deploy-staging
  - deploy-prod

variables:
  ANSIBLE_HOST_KEY_CHECKING: "False"
  ANSIBLE_FORCE_COLOR: "true"

# 模板定義
.ansible_template: &ansible_template
  image: cytopia/ansible:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
    - echo "$ANSIBLE_VAULT_PASSWORD" > .vault_pass

# 代碼驗證階段
lint:
  stage: validate
  image: cytopia/ansible:latest
  script:
    - ansible-lint playbooks/
    - yamllint .
  only:
    - merge_requests
    - main

syntax_check:
  stage: validate
  <<: *ansible_template
  script:
    - ansible-playbook playbooks/site.yml
      -i inventories/dev/inventory.ini
      --syntax-check
      --vault-password-file .vault_pass
  only:
    - merge_requests
    - main

# 測試階段
molecule_test:
  stage: test
  image: cytopia/ansible:latest
  services:
    - docker:dind
  before_script:
    - apk add --no-cache docker py3-pip
    - pip install molecule[docker]
  script:
    - molecule test
  only:
    - merge_requests

# 部署階段
deploy_dev:
  stage: deploy-dev
  <<: *ansible_template
  script:
    - ansible-playbook playbooks/site.yml
      -i inventories/dev/inventory.ini
      --vault-password-file .vault_pass
      --extra-vars "app_version=$CI_COMMIT_SHA environment=development"
  environment:
    name: development
    url: https://dev.example.com
  only:
    - main
  when: manual

deploy_staging:
  stage: deploy-staging
  <<: *ansible_template
  script:
    - ansible-playbook playbooks/site.yml
      -i inventories/staging/inventory.ini
      --vault-password-file .vault_pass
      --extra-vars "app_version=$CI_COMMIT_TAG environment=staging"
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - tags
  when: manual

deploy_prod:
  stage: deploy-prod
  <<: *ansible_template
  script:
    - ansible-playbook playbooks/site.yml
      -i inventories/prod/inventory.ini
      --vault-password-file .vault_pass
      --extra-vars "app_version=$CI_COMMIT_TAG environment=production"
    - ansible-playbook playbooks/verify.yml
      -i inventories/prod/inventory.ini
  environment:
    name: production
    url: https://app.example.com
  only:
    - tags
  when: manual
  allow_failure: false

# 部署後通知
notify_success:
  stage: deploy-prod
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \
      --data "{\"text\":\"✅ 生產環境部署成功: $CI_COMMIT_TAG\"}" \
      $SLACK_WEBHOOK_URL
  only:
    - tags
  when: on_success
```

### 2. GitLab Variables 配置

**專案變數設定**：
```bash
# Settings → CI/CD → Variables
SSH_PRIVATE_KEY: [Protected, Masked]
SSH_KNOWN_HOSTS: [Protected]
ANSIBLE_VAULT_PASSWORD: [Protected, Masked]
SLACK_WEBHOOK_URL: [Protected, Masked]
```

## 進階 CI/CD 模式

### 1. 多分支部署策略

**基於分支的環境映射**：
```yaml
# .gitlab-ci.yml 分支策略
.deploy_template: &deploy_template
  <<: *ansible_template
  script:
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        ENVIRONMENT="dev"
      elif [ "$CI_COMMIT_REF_NAME" = "release" ]; then
        ENVIRONMENT="staging"
      elif [[ "$CI_COMMIT_REF_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        ENVIRONMENT="prod"
      else
        echo "Unknown branch/tag pattern"
        exit 1
      fi

      ansible-playbook playbooks/site.yml \
        -i inventories/$ENVIRONMENT/inventory.ini \
        --vault-password-file .vault_pass \
        --extra-vars "app_version=$CI_COMMIT_SHA environment=$ENVIRONMENT"

deploy_auto:
  stage: deploy
  <<: *deploy_template
  rules:
    - if: $CI_COMMIT_REF_NAME == "main"
      variables:
        ENVIRONMENT: "dev"
    - if: $CI_COMMIT_REF_NAME == "release"
      variables:
        ENVIRONMENT: "staging"
      when: manual
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/
      variables:
        ENVIRONMENT: "prod"
      when: manual
```

### 2. 藍綠部署 CI/CD 整合

**Jenkins Pipeline 藍綠部署**：
```groovy
stage('Blue-Green Deployment') {
    steps {
        script {
            // 部署到 Green 環境
            ansiblePlaybook(
                playbook: 'playbooks/blue-green-deploy.yml',
                inventory: "inventories/${params.ENVIRONMENT}/inventory.ini",
                extras: "--extra-vars 'target_color=green app_version=${params.VERSION}'"
            )

            // 健康檢查
            def healthCheck = ansiblePlaybook(
                playbook: 'playbooks/health-check.yml',
                inventory: "inventories/${params.ENVIRONMENT}/inventory.ini",
                extras: "--extra-vars 'target_color=green'"
            )

            if (healthCheck.result == 'SUCCESS') {
                // 切換流量到 Green
                ansiblePlaybook(
                    playbook: 'playbooks/switch-traffic.yml',
                    inventory: "inventories/${params.ENVIRONMENT}/inventory.ini",
                    extras: "--extra-vars 'active_color=green'"
                )

                // 停止 Blue 環境
                ansiblePlaybook(
                    playbook: 'playbooks/cleanup-blue.yml',
                    inventory: "inventories/${params.ENVIRONMENT}/inventory.ini"
                )
            } else {
                error("Health check failed, aborting deployment")
            }
        }
    }
}
```

### 3. API 整合與通知

**在 Playbook 中整合 API 呼叫**：
```yaml
---
- name: CI/CD Integration with API calls
  hosts: localhost
  connection: local
  vars:
    deployment_start_time: "{{ ansible_date_time.epoch }}"

  tasks:
    # 部署開始通知
    - name: Notify deployment start
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        body_format: json
        body:
          text: "🚀 開始部署 {{ app_name }} v{{ app_version }} 到 {{ environment }}"
          attachments:
            - color: "warning"
              fields:
                - title: "版本"
                  value: "{{ app_version }}"
                  short: true
                - title: "環境"
                  value: "{{ environment }}"
                  short: true
                - title: "執行者"
                  value: "{{ ansible_user_id }}"
                  short: true

    # 觸發 GitLab Pipeline
    - name: Trigger related pipeline
      uri:
        url: "https://gitlab.com/api/v4/projects/{{ gitlab_project_id }}/trigger/pipeline"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ gitlab_token }}"
        body_format: json
        body:
          ref: "{{ git_branch }}"
          variables:
            TRIGGER_SOURCE: "ansible"
            ENVIRONMENT: "{{ environment }}"
      register: pipeline_result
      when: trigger_pipeline | default(false)

    # 部署完成後驗證
    - name: Wait for application to be ready
      uri:
        url: "{{ app_health_url }}"
        method: GET
        status_code: 200
      register: health_check
      until: health_check.status == 200
      retries: 30
      delay: 10

    # 部署成功通知
    - name: Notify deployment success
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        body_format: json
        body:
          text: "✅ {{ app_name }} v{{ app_version }} 部署到 {{ environment }} 成功"
          attachments:
            - color: "good"
              fields:
                - title: "部署時間"
                  value: "{{ (ansible_date_time.epoch | int - deployment_start_time | int) }}秒"
                  short: true
                - title: "應用程式 URL"
                  value: "{{ app_url }}"
                  short: false
      when: health_check is succeeded

    # 更新監控系統
    - name: Update monitoring dashboard
      uri:
        url: "{{ grafana_api_url }}/api/annotations"
        method: POST
        headers:
          Authorization: "Bearer {{ grafana_token }}"
        body_format: json
        body:
          time: "{{ ansible_date_time.epoch | int * 1000 }}"
          text: "Deployed {{ app_name }} v{{ app_version }} to {{ environment }}"
          tags:
            - deployment
            - "{{ environment }}"
            - "{{ app_name }}"
```

## 關鍵實務心法

### 1. 安全性最佳實務
- **秘密管理**：使用 Jenkins Credentials 或 GitLab Variables 管理敏感資訊
- **權限控制**：不同環境使用不同的服務帳號和權限
- **代碼掃描**：整合安全掃描工具到 Pipeline 中
- **稽核日誌**：記錄所有部署活動和變更

### 2. 可靠性保證
- **回滾機制**：每次部署前準備快速回滾方案
- **健康檢查**：部署後自動驗證應用程式狀態
- **漸進式部署**：使用藍綠或金絲雀部署降低風險
- **監控告警**：部署後密切監控關鍵指標

### 3. 效能優化
- **並行執行**：合理使用 Pipeline 並行化提升效率
- **快取機制**：善用 Docker 層快取和依賴快取
- **資源管理**：適當分配 CI/CD 執行資源
- **增量部署**：只部署變更的組件

### 4. 團隊協作
- **分支策略**：建立清楚的 Git 分支和環境映射
- **審核流程**：生產環境部署需要人工審核
- **通知機制**：及時通知相關人員部署狀態
- **文件維護**：保持 Pipeline 配置和流程文件更新

## 作業練習時間

### 練習一：Jenkins Pipeline 設計
1. 建立一個 Jenkins Declarative Pipeline
2. 整合 Ansible Playbook 執行
3. 添加參數化部署（環境、版本選擇）
4. 設定部署後通知機制

### 練習二：GitLab CI/CD 配置
1. 設計完整的 `.gitlab-ci.yml` 配置
2. 實作多階段部署流程（dev → staging → prod）
3. 整合自動化測試和驗證
4. 配置環境變數和秘密管理

### 練習三：藍綠部署實作
1. 設計藍綠部署的 Ansible Playbook
2. 整合到 CI/CD Pipeline 中
3. 實作自動化健康檢查和流量切換
4. 設計回滾機制

### 練習四：API 整合應用
1. 在部署流程中整合 Slack 通知
2. 實作與其他系統的 API 整合
3. 設計部署狀態的監控和追蹤
4. 建立部署 Dashboard

## 常見問題排查

### Q1: Pipeline 執行權限問題
**問題現象：**
```
Permission denied (publickey)
```

**解決方案：**
- 確認 SSH 金鑰已正確配置到 Jenkins/GitLab
- 檢查目標主機的 SSH 權限設定
- 使用 `ssh-agent` 管理多個金鑰
- 驗證 `ansible_user` 權限是否足夠

### Q2: Ansible Vault 密碼問題
**問題現象：**
```
ERROR! Attempting to decrypt but no vault secrets found
```

**解決方案：**
- 確認 Vault 密碼已設定為環境變數或檔案
- 檢查 `--vault-password-file` 路徑是否正確
- 使用 Jenkins Credentials 管理 Vault 密碼
- 驗證 Vault 檔案是否已正確加密

### Q3: 部署卡住或超時
**問題現象：**
Pipeline 執行時間過長或無響應

**解決方案：**
- 設定適當的超時時間
- 檢查網路連接和防火牆設定
- 使用 `async` 和 `poll` 處理長時間任務
- 優化 Playbook 執行效率

### Q4: 環境間配置衝突
**問題現象：**
不同環境的部署結果不一致

**解決方案：**
- 檢查環境變數和 group_vars 配置
- 確保 Inventory 檔案正確分離
- 使用條件判斷處理環境差異
- 建立環境配置驗證機制

## 明日預告
> 明天來聊聊監控
