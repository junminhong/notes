# Day26 - 故障排除與維運
## 今日目標
- 學會 Ansible 故障排除的各種神技
- 掌握維運自動化的實戰心法
- 了解如何從維運菜鳥進化成維運大神

## 筆者的維運血淚史 😅
讓筆者先跟大家分享一個真實且痛苦的經驗：那是一個風雨交加的週五晚上（為什麼事故總是在週五發生？），生產環境的服務突然掛掉了，所有用戶都無法登入。

當時的我：
- 🤦‍♂️ **手忙腳亂**：一台台 SSH 進去檢查，完全不知道問題在哪
- 😱 **病急亂投醫**：重啟這個、重啟那個，越搞越糟
- 😭 **欲哭無淚**：最後發現是某個配置檔案權限錯誤，但已經折騰了 3 小時

那晚之後，筆者就下定決心要學好維運自動化。現在回想起來，如果當時有今天要介紹的這些工具和方法，那個痛苦的週五夜晚就不會那麼慘了 😂

> 💡 **筆者心得**：好的維運工程師和菜鳥的差別，不在於他們遇到的問題多寡，而在於解決問題的效率和預防問題的能力。

## 為什麼筆者推薦用 Ansible 做維運？

經過這幾年的實戰經驗，筆者從一開始用各種雜牌工具（shell script、手工操作、自製腳本），到現在全面擁抱 Ansible，主要有幾個原因：

1. **冪等性救了我無數次**：不怕重複執行，不會越弄越糟
2. **YAML 讓老闆也看得懂**：不用再解釋複雜的 bash script
3. **豐富的模組生態**：幾乎所有維運任務都有現成模組
4. **強大的錯誤處理**：比 shell script 的錯誤處理強太多了
5. **社群支援**：遇到問題 Google 一下就有解答

> 當然，筆者也用過 Puppet、Chef 這些工具，但 Ansible 的學習曲線最友善，特別適合我們這種要快速上手解決問題的維運人員。

## 常見的 Ansible 踩坑分類（筆者親身體驗）

### 1. SSH 連線問題（筆者踩坑指數：⭐⭐⭐⭐⭐）

這是筆者遇過最多次的問題，每次都要花好久時間查：

```bash
# 這個錯誤訊息筆者看過不下百次
UNREACHABLE! => {"changed": false, "msg": "Failed to connect to the host via ssh"}
# 這個也是，通常是 SSH key 的問題
UNREACHABLE! => {"changed": false, "msg": "Authentication failure"}
```

**筆者的診斷三步驟**：
```bash
# 第一步：先確認基本連線（筆者必做的第一件事）
ansible all -i inventory.ini -m ping

# 第二步：用 SSH 手動連看看（通常就能發現問題）
ssh -v user@target-server

# 第三步：檢查 inventory 設定（很多時候是設定檔寫錯）
ansible-inventory -i inventory.ini --list
```

> 💡 **筆者小技巧**：我現在習慣先用 `ssh-copy-id` 把金鑰複製到所有機器，可以省掉很多麻煩。

### 2. 權限問題（筆者被坑過無數次）

```yaml
# 這兩個錯誤訊息筆者深惡痛絕，但也最常見
FAILED! => {"msg": "Missing sudo password"}
FAILED! => {"msg": "User is not in the sudoers file"}
```

**筆者現在都這樣寫**（血的教訓）：
```yaml
# 以前筆者常常忘記加這些參數，現在都寫成模板了
- name: Install packages
  package:
    name: nginx
    state: present
  become: yes                    # 筆者建議：所有系統操作都要加這個
  become_user: root             # 明確指定用戶（避免疑惑）
  become_method: sudo           # 明確指定方法（有些系統預設不是 sudo）
```

### 3. 變數未定義問題（筆者踩坑無數）

```yaml
# 這個錯誤讓筆者痛苦過很多次，特別是在大型 Playbook 中
FAILED! => {"msg": "AnsibleUndefinedVariable: 'database_host' is undefined"}
```

**筆者現在的防坑策略**：
```yaml
# 我現在都會加上 default 值，就不會再踩這個坑
- name: 連接資料庫
  mysql_user:
    name: "{{ app_user }}"
    host: "{{ database_host | default('localhost') }}"  # 筆者必用技巧
    password: "{{ db_password | default('changeme') }}"
```

## 筆者的調試工具箱 🔧（實戰心得）

### 1. 詳細輸出模式（筆者每天都在用）

```bash
# 筆者的調試等級使用心得：
ansible-playbook site.yml -v        # 平常測試用這個就夠
ansible-playbook site.yml -vv       # 出問題時用這個
ansible-playbook site.yml -vvv      # 複雜問題必用，超詳細
ansible-playbook site.yml -vvvv     # 絕招，什麼都看得到（但輸出有點多）
```

**筆者的實戰範例**：
```bash
# 當筆者遇到莫名其妙的錯誤時，一定會這樣做
ansible-playbook -i production deploy.yml -vvv --limit problematic-server
# 通常看了詳細輸出就知道問題在哪了
```

### 2. Debug 模組（筆者的最愛）

筆者現在寫 Playbook 一定會加很多 debug，因為可以看到變數的實際值：

```yaml
---
- name: 筆者的 Debug 範本
  hosts: all
  tasks:
    - name: 收集系統資訊
      setup:
      register: system_info

    # 筆者習慣用這種格式顯示重要資訊
    - name: 顯示筆者關心的系統資訊
      debug:
        msg:
          - "主機名稱: {{ inventory_hostname }}"
          - "IP 位址: {{ ansible_default_ipv4.address }}"
          - "系統版本: {{ ansible_distribution }} {{ ansible_distribution_version }}"
          - "記憶體大小: {{ ansible_memtotal_mb }}MB"
          # 筆者發現：把重要資訊都印出來，問題通常就解決一半了

    - name: 檢查設定檔是否存在
      stat:
        path: /etc/nginx/nginx.conf
      register: nginx_config

    # 筆者小技巧：用 verbosity 控制輸出層級
    - name: 顯示檔案狀態詳情
      debug:
        var: nginx_config
        verbosity: 2  # 只有用 -vv 以上才會顯示，避免輸出太雜亂

    - name: 筆者的條件式除錯
      debug:
        msg: "太好了！Nginx 設定檔存在且可讀取 🎉"
      when: nginx_config.stat.exists and nginx_config.stat.readable
```

### 3. 檢查模式（筆者的安全網）

筆者現在執行任何 Playbook 之前，都會先用檢查模式跑一遍：

```bash
# 筆者的標準流程：
# 1. 先檢查會做什麼改變（超重要！）
ansible-playbook site.yml --check

# 2. 看看具體會改什麼檔案（筆者必做）
ansible-playbook site.yml --check --diff

# 3. 只檢查特定部分（筆者常用技巧）
ansible-playbook site.yml --check --tags database
```

**筆者的實戰檢查策略**：
```yaml
# 筆者現在都會在 Playbook 裡加入這種檢查
- name: 筆者的服務狀態檢查
  service_facts:
  register: service_status

- name: 確認關鍵服務正常運行（筆者的必檢項目）
  assert:
    that:
      - "'nginx.service' in service_status.ansible_facts.services"
      - "service_status.ansible_facts.services['nginx.service'].state == 'running'"
    fail_msg: "慘了！Nginx 服務掛了 😱"
    success_msg: "太好了！Nginx 服務正常運行 ✅"
```

### 4. 限制執行範圍（筆者的救命技巧）

```bash
# 筆者的常用 limit 技巧：
# 只在特定群組執行（安全第一）
ansible-playbook site.yml --limit web-servers

# 只在出問題的機器執行（筆者最愛用這招）
ansible-playbook site.yml --limit "web-01,web-02"

# 使用模式匹配（很方便）
ansible-playbook site.yml --limit "web-*"

# 排除特定機器（當某台機器有問題時超好用）
ansible-playbook site.yml --limit "all:!problematic-server"
```

## 筆者的維運日誌心得 📝

### 1. 日誌記錄策略（血淚經驗）

以前筆者不重視日誌，結果出問題時什麼都查不到。現在筆者都這樣設定：

```ini
# 筆者的 ansible.cfg 標準配置
[defaults]
log_path = /var/log/ansible.log           # 一定要記錄日誌
display_skipped_hosts = False             # 筆者不想看跳過的主機
display_ok_hosts = False                  # OK 的也不用每次都顯示
```

```yaml
# 筆者現在都會在重要的 Playbook 裡加這個
- name: 記錄部署開始時間（筆者的習慣）
  lineinfile:
    path: /var/log/deployment.log
    line: "{{ ansible_date_time.iso8601 }} - 開始部署 {{ app_name }} 版本 {{ app_version }}"
    create: yes
  delegate_to: localhost
  # 這樣出問題時就知道什麼時候開始部署的了
```

### 2. 回調插件（筆者的進階技巧）

```ini
# 筆者的 ansible.cfg 進階設定
[defaults]
stdout_callback = json                    # JSON 格式比較好分析
callback_whitelist = profile_tasks, timer  # 可以看到每個任務花多久時間

# 這設定讓筆者可以知道哪些任務跑比較慢，超實用！
```

## 筆者的維運最佳實務 🎯

### 1. 冪等性驗證（筆者的金科玉律）

筆者現在寫的每個任務都要能重複執行：

```yaml
# 筆者的標準寫法：
- name: 確保應用程式目錄存在
  file:
    path: "{{ app_directory }}"
    state: directory
    owner: "{{ app_user }}"
    mode: '0755'
  # 重複執行也沒關係，這就是 Ansible 的美妙之處

# 筆者最愛的 creates 參數技巧
- name: 解壓應用程式（只執行一次）
  unarchive:
    src: "{{ app_package }}"
    dest: "{{ app_directory }}"
    creates: "{{ app_directory }}/bin/app"  # 檔案存在就跳過，超聰明！

# 筆者的條件判斷標準寫法
- name: 檢查配置檔案是否需要更新
  template:
    src: app.conf.j2
    dest: /etc/app.conf
  register: config_changed
  # 只有真的改變才會觸發重啟

- name: 重新載入服務（只在需要時執行）
  systemd:
    name: app
    state: reloaded
  when: config_changed.changed
  # 這樣就不會無謂地重啟服務了
```

### 2. 分階段部署策略（筆者的安全策略）

筆者以前都是一次部署所有機器，結果一出問題就全軍覆沒。現在筆者都這樣做：

```yaml
# 筆者的分階段部署模板
- name: Phase 1 - 筆者的安全檢查階段
  hosts: all
  serial: "{{ batch_size | default(1) }}"  # 筆者建議：一台一台來
  tasks:
    - name: 檢查系統資源（筆者必檢項目）
      assert:
        that:
          - ansible_memfree_mb > 100        # 至少要有 100MB 記憶體
          - ansible_mounts | selectattr('mount', 'equalto', '/') | map(attribute='size_available') | first > 1000000000  # 至少 1GB 磁碟空間
        fail_msg: "系統資源不足，筆者建議暫停部署"

- name: Phase 2 - 筆者的備份階段（超重要！）
  hosts: all
  tasks:
    - name: 備份當前版本
      archive:
        path: "{{ app_directory }}"
        dest: "/backup/{{ app_name }}-{{ ansible_date_time.epoch }}.tar.gz"
      # 筆者血的教訓：一定要備份！

- name: Phase 3 - 筆者的部署階段
  hosts: all
  serial: 1  # 一台一台部署，安全第一
  tasks:
    - name: 停止服務
      systemd:
        name: "{{ app_name }}"
        state: stopped

    - name: 部署新版本
      # ... 部署任務

    - name: 啟動服務並驗證
      systemd:
        name: "{{ app_name }}"
        state: started

    # 筆者一定會加的健康檢查
    - name: 確認服務正常運行
      uri:
        url: "http://{{ inventory_hostname }}:{{ app_port }}/health"
      retries: 5     # 筆者給 5 次機會
      delay: 10      # 每次等 10 秒
```

### 3. 錯誤處理和回滾（筆者的救命稻草）

筆者現在都會用 block/rescue/always 來處理錯誤：

```yaml
# 筆者的標準錯誤處理模板
- name: 部署應用程式（筆者的完整版本）
  block:
    - name: 下載新版本
      get_url:
        url: "{{ app_download_url }}"
        dest: "/tmp/{{ app_package }}"
        timeout: 300
      # 筆者建議設個 timeout，不然可能等很久

    - name: 停止現有服務
      systemd:
        name: "{{ app_name }}"
        state: stopped

    - name: 備份當前版本（筆者習慣）
      command: cp -r {{ app_directory }} {{ app_directory }}.backup

    - name: 部署新版本
      unarchive:
        src: "/tmp/{{ app_package }}"
        dest: "{{ app_directory }}"

    - name: 啟動服務
      systemd:
        name: "{{ app_name }}"
        state: started

    - name: 驗證部署成功
      uri:
        url: "http://localhost:{{ app_port }}/health"
        status_code: 200
      retries: 3
      delay: 5

  rescue:
    # 筆者的回滾程序
    - name: 部署失敗，筆者開始回滾程序
      debug:
        msg: "慘了！部署失敗了，筆者開始回滾 😱"

    - name: 停止失敗的服務
      systemd:
        name: "{{ app_name }}"
        state: stopped
      ignore_errors: yes  # 筆者加這個因為服務可能已經掛了

    - name: 還原備份版本
      command: mv {{ app_directory }}.backup {{ app_directory }}

    - name: 重啟舊版服務
      systemd:
        name: "{{ app_name }}"
        state: started

    - name: 記錄回滾事件
      lineinfile:
        path: /var/log/deployment.log
        line: "{{ ansible_date_time.iso8601 }} - 筆者執行回滾完成，服務已恢復"

  always:
    # 筆者一定會做的清理工作
    - name: 清理暫存檔案
      file:
        path: "/tmp/{{ app_package }}"
        state: absent

    # 筆者建議：不管成功失敗都要發通知
    - name: 發送部署結果通知
      mail:
        to: devops-team@company.com
        subject: "部署通知 - {{ '成功 🎉' if ansible_failed_task is not defined else '失敗並回滾 😱' }}"
        body: "應用程式 {{ app_name }} 部署結果：{{ '成功' if ansible_failed_task is not defined else '失敗但已成功回滾' }}"
      delegate_to: localhost
```

## 筆者的緊急狀況手冊 🚨

### 緊急診斷五步驟（筆者血淚總結）

當半夜被電話吵醒時，筆者現在都按這個順序檢查：

```bash
# Step 1: 筆者第一步永遠是檢查連線
ansible all -i inventory.ini -m ping
# 如果 ping 不通，問題就很明確了

# Step 2: 檢查目標主機基本狀態
ansible all -i inventory.ini -m setup -a "filter=ansible_*"
# 看看系統還活著嗎

# Step 3: 檢查關鍵服務狀態
ansible all -i inventory.ini -m systemd -a "name=nginx"
# 服務還在跑嗎？

# Step 4: 查看最近的系統日誌
ansible all -i inventory.ini -m command -a "journalctl -n 50"
# 通常錯誤訊息就在這裡

# Step 5: 檢查系統資源
ansible all -i inventory.ini -m command -a "df -h"
ansible all -i inventory.ini -m command -a "free -m"
# 是不是磁碟滿了或記憶體不夠？
```

### 筆者的緊急回滾 Playbook

```yaml
---
# emergency-rollback.yml（筆者的救命 Playbook）
- name: 筆者的緊急回滾程序
  hosts: "{{ target_hosts | default('all') }}"
  vars_prompt:
    - name: confirm_rollback
      prompt: "筆者要確認：真的要執行緊急回滾嗎？請輸入 'ROLLBACK' 確認"
      private: no

  pre_tasks:
    - name: 確認回滾操作
      fail:
        msg: "筆者說：回滾操作已取消，請再次確認"
      when: confirm_rollback != "ROLLBACK"

    - name: 記錄緊急回滾開始
      debug:
        msg: "筆者開始執行緊急回滾程序 - {{ ansible_date_time.iso8601 }}"

  tasks:
    - name: 停止現有服務
      systemd:
        name: "{{ app_name }}"
        state: stopped
      ignore_errors: yes  # 筆者經驗：服務可能已經掛了

    - name: 查找最新的備份檔案
      find:
        paths: /backup
        patterns: "{{ app_name }}-*.tar.gz"
        age: -7d  # 筆者只找一週內的備份
      register: backup_files

    - name: 還原最新備份
      unarchive:
        src: "{{ (backup_files.files | sort(attribute='mtime') | last).path }}"
        dest: "{{ app_directory | dirname }}"
      when: backup_files.files | length > 0

    - name: 重啟服務
      systemd:
        name: "{{ app_name }}"
        state: started
        daemon_reload: yes

    - name: 驗證服務恢復
      uri:
        url: "http://{{ inventory_hostname }}:{{ app_port }}/health"
        timeout: 10
      retries: 5
      delay: 3
      # 筆者會等一下讓服務完全啟動
```

## 筆者的效能優化心得 ⚡

### ansible.cfg 效能調校（筆者的實戰配置）

```ini
# 筆者的高效能 ansible.cfg 配置
[defaults]
forks = 20                    # 筆者建議至少 20（根據你的機器數量調整）
host_key_checking = False     # 筆者關掉這個，省時間
fact_caching = jsonfile       # 筆者一定開啟 fact 快取
fact_caching_connection = /tmp/ansible_facts
fact_caching_timeout = 3600   # 快取 1 小時，夠用了

[ssh_connection]
# 筆者的 SSH 最佳化配置
ssh_args = -o ControlMaster=auto -o ControlPersist=60s -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes
pipelining = True             # 筆者強烈推薦開啟這個
```

### 任務優化技巧（筆者的小撇步）

```yaml
# 筆者的快速部署技巧
- name: 快速部署（不收集系統資訊）
  hosts: all
  gather_facts: no           # 筆者發現這樣快很多
  tasks:
    - name: 只在需要時收集特定資訊
      setup:
        filter: "ansible_distribution*"
      when: need_os_info | default(false)

# 筆者的非同步處理大檔案下載
- name: 下載大型檔案（筆者的非同步技巧）
  get_url:
    url: "{{ large_file_url }}"
    dest: "/tmp/large_file"
  async: 3600                # 最大等待 1 小時
  poll: 30                   # 每 30 秒檢查一次
  register: download_task

- name: 筆者繼續做其他事情
  debug:
    msg: "檔案在背景下載中，筆者先去做別的事"

- name: 等待下載完成
  async_status:
    jid: "{{ download_task.ansible_job_id }}"
  register: download_result
  until: download_result.finished
  retries: 120  # 筆者給 1 小時時間
  delay: 30
```

## 作業練習時間

### 練習一：筆者建議的故障診斷實戰
1. 故意在 Playbook 中製造問題，練習筆者教的診斷技巧
2. 嘗試用不同的 `-v` 等級來找問題
3. 練習用 `debug` 模組來追蹤變數值

### 練習二：筆者的監控 Playbook 挑戰
1. 寫一個像筆者一樣的系統健康檢查 Playbook
2. 加入筆者建議的所有檢查項目
3. 讓它能產生好看的報告

### 練習三：筆者的回滾機制練習
1. 為你的應用加入筆者的備份和回滾機制
2. 故意讓部署失敗，測試自動回滾是否有效
3. 確保筆者的錯誤處理流程都能正常運作

## 筆者的維運心法總結 💡

經過這些年的維運經驗，筆者想跟大家分享幾個重要心得：

### 1. 筆者的四大維運原則
- **預防勝於治療**：花時間設計好的檢查機制，比半夜被叫醒修 bug 好太多了
- **自動化一切**：能自動化的就不要手工做，筆者已經被手工操作坑過無數次
- **詳細記錄**：日誌、監控、文件，這些看起來很煩，但關鍵時刻救你一命
- **小步快跑**：不要一次改太多，一步一步來比較安全

### 2. 筆者推薦的工具組合
- **Ansible** + **Prometheus** + **Grafana** = 筆者的黃金組合
- **ELK Stack** 處理日誌分析
- **Git** 管理所有配置（筆者強烈建議）
- **Slack** 或 **Teams** 接收告警通知

### 3. 筆者的成長建議
- 多看官方文件（雖然有點枯燥，但很重要）
- 加入 Ansible 社群，學習別人的經驗
- 建立自己的 Playbook 模板庫
- 定期回顧和改進維運流程

> 💡 **筆者最後的碎念**：維運這條路很辛苦，但也很有成就感。每次成功解決一個複雜問題，或是建立一個自動化流程節省大家時間，那種成就感是無可取代的。加油！

## 明日預告
> 明天筆者要跟大家分享安全強化與法規遵循，讓你的系統不只穩定，還要安全！
